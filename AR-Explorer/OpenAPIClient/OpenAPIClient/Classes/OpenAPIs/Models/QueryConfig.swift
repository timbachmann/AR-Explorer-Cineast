//
// QueryConfig.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct QueryConfig: Codable, JSONEncodable, Hashable {

    public enum Hints: String, Codable, CaseIterable {
        case exact = "exact"
        case inexact = "inexact"
        case lsh = "lsh"
        case ecp = "ecp"
        case mi = "mi"
        case pq = "pq"
        case sh = "sh"
        case va = "va"
        case vaf = "vaf"
        case vav = "vav"
        case sequential = "sequential"
        case empirical = "empirical"
    }
    public enum Distance: String, Codable, CaseIterable {
        case chisquared = "chisquared"
        case correlation = "correlation"
        case cosine = "cosine"
        case hamming = "hamming"
        case jaccard = "jaccard"
        case kullbackleibler = "kullbackleibler"
        case chebyshev = "chebyshev"
        case euclidean = "euclidean"
        case squaredeuclidean = "squaredeuclidean"
        case manhattan = "manhattan"
        case minkowski = "minkowski"
        case spannorm = "spannorm"
        case haversine = "haversine"
    }
    public var queryId: String?
    public var hints: Set<Hints>?
    public var relevantSegmentIds: Set<String>?
    public var distance: Distance?
    public var distanceWeights: [Float]?
    public var norm: Float?
    public var resultsPerModule: Int?
    public var maxResults: Int?
    public var distanceIfEmpty: AnyCodable?
    public var correspondenceFunctionIfEmpty: AnyCodable?
    public var correspondenceFunction: AnyCodable?
    public var distanceWeightsIfEmpty: AnyCodable?
    public var normIfEmpty: AnyCodable?
    public var rawResultsPerModule: Int?

    public init(queryId: String? = nil, hints: Set<Hints>? = nil, relevantSegmentIds: Set<String>? = nil, distance: Distance? = nil, distanceWeights: [Float]? = nil, norm: Float? = nil, resultsPerModule: Int? = nil, maxResults: Int? = nil, distanceIfEmpty: AnyCodable? = nil, correspondenceFunctionIfEmpty: AnyCodable? = nil, correspondenceFunction: AnyCodable? = nil, distanceWeightsIfEmpty: AnyCodable? = nil, normIfEmpty: AnyCodable? = nil, rawResultsPerModule: Int? = nil) {
        self.queryId = queryId
        self.hints = hints
        self.relevantSegmentIds = relevantSegmentIds
        self.distance = distance
        self.distanceWeights = distanceWeights
        self.norm = norm
        self.resultsPerModule = resultsPerModule
        self.maxResults = maxResults
        self.distanceIfEmpty = distanceIfEmpty
        self.correspondenceFunctionIfEmpty = correspondenceFunctionIfEmpty
        self.correspondenceFunction = correspondenceFunction
        self.distanceWeightsIfEmpty = distanceWeightsIfEmpty
        self.normIfEmpty = normIfEmpty
        self.rawResultsPerModule = rawResultsPerModule
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case queryId
        case hints
        case relevantSegmentIds
        case distance
        case distanceWeights
        case norm
        case resultsPerModule
        case maxResults
        case distanceIfEmpty
        case correspondenceFunctionIfEmpty
        case correspondenceFunction
        case distanceWeightsIfEmpty
        case normIfEmpty
        case rawResultsPerModule
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(queryId, forKey: .queryId)
        try container.encodeIfPresent(hints, forKey: .hints)
        try container.encodeIfPresent(relevantSegmentIds, forKey: .relevantSegmentIds)
        try container.encodeIfPresent(distance, forKey: .distance)
        try container.encodeIfPresent(distanceWeights, forKey: .distanceWeights)
        try container.encodeIfPresent(norm, forKey: .norm)
        try container.encodeIfPresent(resultsPerModule, forKey: .resultsPerModule)
        try container.encodeIfPresent(maxResults, forKey: .maxResults)
        try container.encodeIfPresent(distanceIfEmpty, forKey: .distanceIfEmpty)
        try container.encodeIfPresent(correspondenceFunctionIfEmpty, forKey: .correspondenceFunctionIfEmpty)
        try container.encodeIfPresent(correspondenceFunction, forKey: .correspondenceFunction)
        try container.encodeIfPresent(distanceWeightsIfEmpty, forKey: .distanceWeightsIfEmpty)
        try container.encodeIfPresent(normIfEmpty, forKey: .normIfEmpty)
        try container.encodeIfPresent(rawResultsPerModule, forKey: .rawResultsPerModule)
    }
}

